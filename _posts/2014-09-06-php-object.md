---
layout: post
title: php之面向对象
description: php使用面向对象开发的好处：易维护，质量高，效率高，易扩展，通过本篇博客，使大家更进一步的学习和了解面向对象编程。

category: blog
---

##面向对象的基本概念

这里所指的面向对象，准确的说应该叫做面向对象编程(OOP),是面向对象的一部分。面向对象包括3部分内容：面向对象分析(OOA)、面向对象设计(OOD),以及面向对象编程(OOP),面向对象编程的两个重要概念是类和对象。

##类

类是属相和方法的集合，是面向对象编程的核心和基础，通过类可以将零散的用于实现某项功能的代码进行有效管理。例如创建一个运动类，包括5个属性：姓名、身高、体重、年龄和性别。

##对象

对象时类进行实例化后的产物，是一个实体。我们可以这样理解对象和类的关系：对象实际上就是"有血有肉的能摸得到看的到的"一个类。

##面向对象编程的三大特点

三大特性是：封装,继承,多态  

所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。 简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。


所谓继承是指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；

 

所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。

##如何抽象出一个类？

使用一个关键字class和后面加上一个你想要的类名以及加上一对大括号， 这样一个类的结构就定义出来了

    class 类名
    {
    }

一个简单的类

    <?php
    class Person
    {
    // 下面是人的成员属性
    var $name;  //人的名子
    var $sex;   //人的性别
    var $age;   //人的年龄
 
    // 下面是人的成员方法
    function say() // 这个人可以说话的方法
    {
        echo "这个人在说话";
    }
 
    function run() // 这个人可以走路的方法
    {
        echo "这个人在走路";
    }
    }
    ?>

##如何实例化对象

当定义好类后，我们使用new关键字来生成一个对象。

$对象名称 = new 　类名称（）;

    <?php
    class Person
    {
    //下面是人的成员属性
    var $name; //人的名字
    var $sex; //人的性别
    var $age; //人的年龄
 
    //下面是人的成员方法
    function say() { //这个人可以说话的方法
        echo "这个人在说话";
    }
 
    function run() { //这个人可以走路的方法
        echo "这个人在走路";
    }
    }
 
    $p1=new Person();
    $p3=new Person();
    ?>

##如何去使用对象中的成员

上面看到PHP对象中的成员有两种一种是成员属性， 一种是成员方法。对象我们以经可以声明了，$p1=new Person(); 怎么去使用对象的成员呢？要想访问对象中的成员就要使用一个特殊的操作符”->”来完成对象成员的访问：

对象->属性 $p1->name; $p2->age; $p3->sex;

对象->方法 $p1->say(); $p2->run(); 如下面实例:

    <?php
    class Person
    {
    // 下面是人的成员属性
    var $name;      // 人的名子
    var $sex;       // 人的性别
    var $age;       // 人的年龄
 
    // 下面是人的成员方法
    function say() // 这个人可以说话的方法
    {
        echo "这个人在说话";
    }
 
    function run() // 这个人可以走路的方法
    {
        echo "这个人在走路";
    }
    }
 
	$p1 = new Person(); //创建实例对象$p1
	$p2 = new Person(); //创建实例对象$p2
	$p3 = new Person(); //创建实例对象$p3
 
	// 下面三行是给$p1对象属性赋值
	$p1->name = "张三";
	$p1->sex = "男";
	$p1->age = 20;
	 
	// 下面三行是访问$p1对象的属性
	echo "p1对象的名子是：" . $p1->name;
	echo "p1对象的性别是：" . $p1->sex;
	echo "p1对象的年龄是：" . $p1->age;
	 
	// 下面两行访问$p1对象中的方法
	$p1->say();
	$p1->run();
	 
	// 下面三行是给$p2对象属性赋值
	$p2->name = "李四";
	$p2->sex = "女";
	$p2->age = 30;
	 
	// 下面三行是访问$p2对象的属性
	echo "p2对象的名子是：" . $p2->name;
	echo "p2对象的性别是：" . $p2->sex;
	echo "p2对象的年龄是：" . $p2->age;
	 
	// 下面两行访问$p2对象中的方法
	$p2->say();
	$p2->run();
	 
	// 下面三行是给$p3对象属性赋值
	$p3->name="王五";
	$p3->sex="男";
	$p3->age=40;
	 
	// 下面三行是访问$p3对象的属性
	echo "p3对象的名子是：" . $p3->name;
	echo "p3对象的性别是：" . $p3->sex;
	echo "p3对象的年龄是：" . $p3->age;
	 
	// 下面两行访问$p3对象中的方法
	$p3->say();
	$p3->run();
	?>

从上例中可以看出只是对象里面的成员就要使用对象->属性 、对象->方法 形式访问，再没有第二种方法来访问对象中的成员了。

#$this 的使用

$this就是对象内部代表这个对象的引用，在对象内部和调用本对象的成员和对象外部调用对象的成员所使用的方式是一样的。

$this->属性： $this->name; $this->age; $this->sex;

$this->方法 ：$this->say(); $this->run();

##构造方法__construct()与析构方法__destruct()

当创建一个对象时，它将自动调用构造函数，也就是使用new这个关键字来实例化对象的时候自动调用构造方法。

在一个类中只能声明一个构造方法，而是只有在每次创建对象的时候都会去调用一次构造方法，不能主动的调用这个方法，所以通常用它执行一些有用的初始化任务。比如对成属性在创建对象的时候赋初值。

	<?
	// 创建一个人类
	class Person
	{
    // 下面是人的成员属性
    var $name;  // 人的名子
    var $sex;   // 人的性别
    var $age;   // 人的年龄
 
    // 定义一个构造方法参数为姓名$name、性别$sex和年龄$age
    function __construct($name, $sex, $age)
    {
        // 通过构造方法传进来的$name给成员属性$this->name赋初使值
        $this->name = $name;
 
        // 通过构造方法传进来的$sex给成员属性$this->sex赋初使值
        $this->sex = $sex;
 
        // 通过构造方法传进来的$age给成员属性$this->age赋初使值
        $this->age = $age;
    }
 
    // 这个人的说话方法
    function say()
    {
        echo "我的名子叫：" . $this->name . " 性别：" . $this->sex . " 我的年龄是：" . $this->age;
    }
    }
 
	// 通过构造方法创建3个对象$p1、p2、$p3,分别传入三个不同的实参为姓名、性别和年龄
	$p1 = new Person("张三","男", 20);
	$p2 = new Person("李四","女", 30);
	$p3 = new Person("王五","男", 40);
 
	// 下面访问$p1对象中的说话方法
	$p1->say();
	 
	// 下面访问$p2对象中的说话方法
	$p2->say();
	 
	// 下面访问$p3对象中的说话方法
	$p3->say();
	?>

输出结果为：

    我的名子叫：张三 性别：男 我的年龄是：20我的名子叫：李四 性别：女 我的年龄是：30我的名子叫：王五 性别：男 我的年龄是：40

析构函数：

与构造函数相对的就是析构函数。析构函数允许在销毁一个类之前执行的一些操作或完成一些功能，比如说关闭文件， 释放结果集等，析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行，也就是对象在内存中被销毁前调用析构函数。与构造函数的名称类似， 一个类的析构函数名称必须是__destruct( )。析构函数不能带有任何参数。

格式：function __destruct ( ) { ... ... }

	<?
	// 创建一个人类
	class Person
	{
    // 下面是人的成员属性
    var $name;  // 人的名子
    var $sex;   // 人的性别
    var $age;   // 人的年龄
 
    // 定义一个构造方法参数为姓名$name、性别$sex和年龄$age
    function __construct($name, $sex, $age)
    {
        // 通过构造方法传进来的$name给成员属性$this->name赋初使值
        $this->name = $name;
         
        // 通过构造方法传进来的$sex给成员属性$this->sex赋初使值
        $this->sex = $sex;
         
        // 通过构造方法传进来的$age给成员属性$this->age赋初使值
        $this->age = $age;
    }
 
    // 这个人的说话方法
    function say()
    {
        echo "我的名子叫：" . $this->name . " 性别：" . $this->sex . " 我的年龄是：" . $this->age;
    }
 
    // 这是一个析构函数,在对象销毁前调用
    function __destruct()
    {
        echo "再见" . $this->name;
    }
    }
 
	// 通过构造方法创建3个对象$p1、p2、$p3,分别传入三个不同的实参为姓名、性别和年龄
	$p1 = new Person("张三", "男", 20);
	$p2 = new Person("李四", "女", 30);
	$p3 = new Person("王五", "男", 40);
	 
	// 下面访问$p1对象中的说话方法
	$p1->say();
	 
	// 下面访问$p2对象中的说话方法
	$p2->say();
	 
	// 下面访问$p3对象中的说话方法
	$p3->say();
	?>

输出结果为：

    我的名子叫：张三 性别：男 我的年龄是：20我的名子叫：李四 性别：女 我的年龄是：30我的名子叫：王五
    性别：男 我的年龄是：40
    再见王五
    再见李四
    再见张三

注意：

由于类实例是以堆栈的形式放在内存中，所以最后调用 析构函数 的时候，输出顺序是按 后进先出 的原则！

##封装性(var 与 public，protected,private的关系)

通过private就可以把人的成员（成员属性和成员方法）封装上了。封装上的成员就不能被类外面直接访问了，只有对象内部自己可以访问，下面的代码会产生错误：

	<?php
	class Person
	{
    // 下面是人的成员属性
    private $name;      // 人的名子，被private封装上了
    private $sex;       // 人的性别, 被private封装上了
    private $age;       // 人的年龄, 被private封装上了
 
    // 这个人可以说话的方法
    function say()
    {
        echo "我的名子叫：" . $this->name . " 性别：" . $this->sex . " 我的年龄是：" . $this->age;
    }
 
    // 这个人可以走路的方法, 被private封装上了
    private function run()
    {
        echo "这个人在走路";
    }
	}
	 
	// 实例化一个人的实例对象
	$p1 = new Person();
	 
	// 试图去给私有的属性赋值， 结果会发生错误
	$p1->name = "张三";
	$p1->sex = "男";
	$p1->age = 20;
	 
	// 试图去打印私有的属性， 结果会发生错误
	echo $p1->name;
	echo $p1->sex;
	echo $p1->age;
	 
	// 试图去打印私有的成员方法， 结果会发生错误
	$p1->run();
	?>

输出结果为：

    Fatal error: Cannot access private property Person::$name
    Fatal error: Cannot access private property Person::$sex
    Fatal error: Cannot access private property Person::$age
    Fatal error: Cannot access private property Person::$name
    Fatal error: Call to private method Person::run() from context ' '

从上面的实例可以看到， 私有的成员是不能被外部访问的， 因为私有成员只能在本对象内部自己访问，比如，$p1这个对象自己想把他的私有属性说出去，在say()这个方法里面访问了私有属性，这样是可以。

没有加任何访问控制，默认的是public的，任何地方都可以访问。
	
	// 这个人可以说话的方法, 说出自己的私有属性，在这里也可以访问私有方法
	function say()
	{
    echo "我的名子叫：" . $this->name . " 性别：" . $this->sex . " 我的年龄是：" . $this->age;
 
    // 在这里也可以访问私有方法
    //$this->run();
    }

因为成员方法say()是公有的， 所以我们在类的外部调用say()方法是可以的，改变上面的代码：
	
	<?php
	class Person
	{
    // 下面是人的成员属性
    private $name;  //人的名子,被private封装上了
    private $sex;   //人的性别, 被private封装上了
    private $age;   //人的年龄, 被private封装上了
 
    // 定义一个构造方法参数为私有的属性姓名$name、性别$sex和年龄$age进行赋值
    function __construct($name, $sex, $age)
    {
        // 通过构造方法传进来的$name给私有成员属性$this->name赋初使值
        $this->name = $name;
 
        // 通过构造方法传进来的$sex给私有成员属性$this->sex赋初使值
        $this->sex = $sex;
 
        // 通过构造方法传进来的$age给私有成员属性$this->age赋初使值
        $this->age = $age;
    }
 
    // 这个人可以说话的方法, 说出自己的私有属性,在这里也可以访问私有方法
    function say()
    {
        echo "我的名子叫：" . $this->name . " 性别：" . $this->sex . " 我的年龄是：" . $this->age;
    }
	}
	 
	// 通过构造方法创建3个对象$p1、p2、$p3,分别传入三个不同的实参为姓名、性别和年龄
	$p1 = new Person("张三", "男", 20);
	$p2 = new Person("李四", "女", 30);
	$p3 = new Person("王五", "男", 40);
	 
	// 下面访问$p1对象中的说话方法
	$p1->say();
	 
	// 下面访问$p2对象中的说话方法
	$p2->say();
	 
	// 下面访问$p3对象中的说话方法
	$p3->say();
	?>

输出结果为：

    我的名子叫：张三 性别：男 我的年龄是：20我的名子叫：李四 性别：女 我的年龄是：30我的名子叫：王五 性别：男 我的年龄是：40

更多面向对象知识点参考 http://www.cnblogs.com/xiaochaohuashengmi/archive/2010/09/10/1823042.html